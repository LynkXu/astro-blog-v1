<canvas id="background-canvas"></canvas>

<style>
  #background-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: -1;
    pointer-events: none;
  }
</style>

<script>
  const canvas = document.getElementById('background-canvas');
  if (canvas) {
    const ctx = canvas.getContext('2d');
    let width, height;
    let circles = [];
    let animationId;
    let time = 0;

    function resize() {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
      initCircles();
    }

    function initCircles() {
      circles = [];
      const count = 4;
      for (let i = 0; i < count; i++) {
        circles.push({
          x: Math.random() * width,
          y: Math.random() * height,
          baseR: Math.min(width, height) * (0.25 + Math.random() * 0.35),
          dx: (Math.random() - 0.5) * 0.3,
          dy: (Math.random() - 0.5) * 0.3,
          phase: Math.random() * Math.PI * 2, // 呼吸相位
          breathSpeed: 0.008 + Math.random() * 0.006, // 呼吸速度
          breathAmp: 0.03 + Math.random() * 0.02, // 呼吸幅度
        });
      }
    }

    function draw() {
      if (!canvas.isConnected) {
        cancelAnimationFrame(animationId);
        return;
      }

      ctx.clearRect(0, 0, width, height);
      time += 1;
      
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark' || 
                     (!document.documentElement.hasAttribute('data-theme') && window.matchMedia('(prefers-color-scheme: dark)').matches);

      if (isDark) {
        animationId = requestAnimationFrame(draw);
        return;
      }

      circles.forEach((circle, index) => {
        // 呼吸效果：半径微微变化
        const breathOffset = Math.sin(time * circle.breathSpeed + circle.phase) * circle.breathAmp;
        const currentR = circle.baseR * (1 + breathOffset);
        
        // 透明度也随呼吸微微变化
        const alphaBase = 0.25 + index * 0.08;
        const alphaOffset = Math.sin(time * circle.breathSpeed + circle.phase) * 0.08;
        
        ctx.beginPath();
        ctx.arc(circle.x, circle.y, currentR, 0, Math.PI * 2);
        ctx.strokeStyle = '#E3E3E3';
        ctx.lineWidth = 1;
        ctx.globalAlpha = alphaBase + alphaOffset;
        ctx.stroke();

        // 更新位置
        circle.x += circle.dx;
        circle.y += circle.dy;

        // 边界反弹（柔和处理）
        if (circle.x < -currentR * 0.5) circle.dx = Math.abs(circle.dx);
        if (circle.x > width + currentR * 0.5) circle.dx = -Math.abs(circle.dx);
        if (circle.y < -currentR * 0.5) circle.dy = Math.abs(circle.dy);
        if (circle.y > height + currentR * 0.5) circle.dy = -Math.abs(circle.dy);
      });

      animationId = requestAnimationFrame(draw);
    }

    window.addEventListener('resize', resize);
    resize();
    draw();
  }
</script>
